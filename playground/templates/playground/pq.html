{% load static %}
<!DOCTYPE html>
<html>
<head>
  <title>Priority Queue Playground</title>
  <link rel="stylesheet" href="{% static 'playground/css/style.css' %}">
</head>
<body>
  <div class="pq-container">
    <h1>Priority Queue Playground</h1>
    <p>Insert items with priorities and retrieve by highest/lowest priority.</p>

    <div class="pq-controls">
      <div class="input-area">
        <input type="text" id="pqItem" placeholder="Item" />
        <input type="number" id="pqPriority" placeholder="Priority" step="any" />
        <button onclick="insert()">Insert</button>
      </div>

      <div class="button-area" style="margin-top: 10px;">
        <button onclick="pop()">Pop</button>
        <button onclick="resetQueue()">Reset</button>
      </div>
    </div>

    <pre id="pqDisplay" class="empty">Queue is empty.</pre>
  </div>

  <script>
    // Min-priority queue: lower priority value = higher priority
    const priorityQueue = [];

    function updateDisplay() {
      const display = document.getElementById('pqDisplay');
      if (priorityQueue.length === 0) {
        display.textContent = 'Queue is empty.';
        display.classList.add('empty');
        return;
      }
      display.classList.remove('empty');
      const sorted = [...priorityQueue].sort((a, b) => a.priority - b.priority);
      const lines = sorted.map(entry => `${entry.item} (priority ${entry.priority})`);
      display.textContent = lines.join('\n');
    }

    function insert() {
      const item = document.getElementById('pqItem').value.trim();
      const priority = parseFloat(document.getElementById('pqPriority').value);
      if (!item || isNaN(priority)) {
        alert('Please enter both item and a valid priority.');
        return;
      }
      priorityQueue.push({ item, priority });
      updateDisplay();
      document.getElementById('pqItem').value = '';
      document.getElementById('pqPriority').value = '';
    }

    function pop() {
      if (priorityQueue.length === 0) {
        alert('Queue is empty.');
        return;
      }
      // Remove item with lowest priority value (min-heap behavior)
      let minIndex = 0;
      for (let i = 1; i < priorityQueue.length; i++) {
        if (priorityQueue[i].priority < priorityQueue[minIndex].priority) {
          minIndex = i;
        }
      }
      const popped = priorityQueue.splice(minIndex, 1)[0];
      alert(`Popped: ${popped.item} (priority ${popped.priority})`);
      updateDisplay();
    }

    function resetQueue() {
      priorityQueue.length = 0;
      updateDisplay();
    }

    updateDisplay();
  </script>
</body>
</html>
