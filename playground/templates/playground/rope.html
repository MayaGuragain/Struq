{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rope Playground</title>
  <link rel="stylesheet" href="{% static 'playground/css/style.css' %}">
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; max-width: 700px; }
    input, button { margin: 6px 10px 6px 0; padding: 6px 12px; }
    #ropeDisplay {
      margin-top: 20px;
      padding: 12px;
      border: 1px solid #ccc;
      min-height: 60px;
      white-space: pre-wrap;
      font-family: monospace;
      background: #f9f9f9;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <h1>Rope (String Tree) Playground</h1>
  <p>Efficiently manage large strings with split and concat operations.</p>

  <input type="text" id="inputString" placeholder="Enter string" />
  <button onclick="concatString()">Concat</button>
  <br />
  <input type="number" id="splitIndex" placeholder="Split index" min="0" />
  <button onclick="splitString()">Split</button>
  <button onclick="resetRope()">Reset Rope</button>

  <div id="ropeDisplay">Rope is empty.</div>

  <script>
    // Simple Rope Node: leaf or internal
    class RopeNode {
      constructor(value = '') {
        this.left = null;
        this.right = null;
        this.weight = value.length; // length of left subtree for internal nodes, or length of string for leaf
        this.value = value;         // non-empty only for leaves
      }

      isLeaf() {
        return this.left === null && this.right === null;
      }

      length() {
        if (this.isLeaf()) return this.value.length;
        return (this.left ? this.left.length() : 0) + (this.right ? this.right.length() : 0);
      }

      toString() {
        if (this.isLeaf()) return this.value;
        return (this.left ? this.left.toString() : '') + (this.right ? this.right.toString() : '');
      }
    }

    class Rope {
      constructor(initial = '') {
        this.root = new RopeNode(initial);
      }

      concat(str) {
        let newNode = new RopeNode(str);
        let oldRoot = this.root;
        let newRoot = new RopeNode();
        newRoot.left = oldRoot;
        newRoot.right = newNode;
        newRoot.weight = oldRoot.length();
        this.root = newRoot;
      }

      split(index) {
        if (index < 0 || index > this.root.length()) {
          alert('Index out of range.');
          return [null, null];
        }
        return this._split(this.root, index);
      }

      _split(node, index) {
        if (node.isLeaf()) {
          let leftStr = node.value.substring(0, index);
          let rightStr = node.value.substring(index);
          return [new RopeNode(leftStr), new RopeNode(rightStr)];
        }
        if (index < node.weight) {
          let [leftSplit, rightSplit] = this._split(node.left, index);
          let rightNode = new RopeNode();
          rightNode.left = rightSplit;
          rightNode.right = node.right;
          rightNode.weight = rightSplit ? rightSplit.length() : 0;
          return [leftSplit, rightNode];
        } else {
          let [leftSplit, rightSplit] = this._split(node.right, index - node.weight);
          let leftNode = new RopeNode();
          leftNode.left = node.left;
          leftNode.right = leftSplit;
          leftNode.weight = node.left ? node.left.length() : 0;
          return [leftNode, rightSplit];
        }
      }

      toString() {
        return this.root.toString();
      }

      setRoot(node) {
        this.root = node;
      }
    }

    const rope = new Rope();

    function updateDisplay() {
      const display = document.getElementById('ropeDisplay');
      const text = rope.toString();
      display.textContent = text.length ? text : 'Rope is empty.';
    }

    function concatString() {
      const input = document.getElementById('inputString').value;
      if (!input) {
        alert('Enter a string to concat.');
        return;
      }
      rope.concat(input);
      document.getElementById('inputString').value = '';
      updateDisplay();
    }

    function splitString() {
      const idxInput = document.getElementById('splitIndex');
      let index = parseInt(idxInput.value);
      if (isNaN(index)) {
        alert('Enter a valid split index.');
        return;
      }
      let [left, right] = rope.split(index);
      if (left === null && right === null) return;
      // For demo, set rope root to left part and show right part as alert
      rope.setRoot(left);
      alert('Right part after split: "' + (right ? right.toString() : '') + '"');
      idxInput.value = '';
      updateDisplay();
    }

    function resetRope() {
      rope.setRoot(new RopeNode(''));
      updateDisplay();
    }

    updateDisplay();
  </script>
</body>
</html>
